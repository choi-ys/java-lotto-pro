3단계-로또(자동)
===
# 미션 설명
### 기능 요구 사항
- 로또 구입 금액을 입력하면 구입 금액에 해당하는 로또를 발급해야 한다.
- 로또 1장의 가격은 1000원 이다.
- 프로그램 실행 예시 
    ```
    구입금액을 입력해 주세요.
    14000
    14개를 구매했습니다.
    [8, 21, 23, 41, 42, 43]
    [3, 5, 11, 16, 32, 38]
    [7, 11, 16, 35, 36, 44]
    [1, 8, 11, 31, 41, 42]
    [13, 14, 16, 38, 42, 45]
    [7, 11, 30, 40, 42, 43]
    [2, 13, 22, 32, 38, 45]
    [23, 25, 33, 36, 39, 41]
    [1, 3, 5, 14, 22, 45]
    [5, 9, 38, 41, 43, 44]
    [2, 8, 9, 18, 19, 21]
    [13, 14, 18, 21, 23, 35]
    [17, 21, 29, 37, 42, 45]
    [3, 8, 27, 30, 35, 44]
    
    지난 주 당첨 번호를 입력해 주세요.
    1, 2, 3, 4, 5, 6
    
    당첨 통계
    ---------
    3개 일치 (5000원)- 1개
    4개 일치 (50000원)- 0개
    5개 일치 (1500000원)- 0개
    6개 일치 (2000000000원)- 0개
    총 수익률은 0.35입니다.(기준이 1이기 때문에 결과적으로 손해라는 의미임)
    ```
---

### 힌트
- 로또 자동 생성은 Collections.shuffle() 메소드를 사용한다.
- Collections.sort() 메소드를 활용해 정렬 가능하다.
- ArrayList의 contains() 메소드를 활용하면 어떤 값이 존재하는지 유무를 판단할 수 있다.

### 요구사항
- 모든 기능을 TDD로 구현해 단위 테스트가 존재해야 한다.
  - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.
  - UI 로직을 InputView, ResultView와 같은 클래스를 추가해 분리한다.
- indent(인덴트, 들여쓰기) depth를 2를 넘지 않도록 구현한다. 1까지만 허용한다.
  - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메소드)를 분리하면 된다.
- 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다.
  - 함수(또는 메소드)가 한 가지 일만 잘 하도록 구현한다.
- 모든 로직에 단위 테스트를 구현한다. 단, UI(System.out, System.in) 로직은 제외
  - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.
  - UI 로직을 InputView, ResultView와 같은 클래스를 추가해 분리한다.
- 자바 코드 컨벤션을 지키면서 프로그래밍한다.
  - 참고문서 : https://google.github.io/styleguide/javaguide.html 또는 https://myeonguni.tistory.com/1596
- else 예약어를 쓰지 않는다.
  - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
  - else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.

### 기능 목록 및 commit 로그 요구사항
- 기능을 구현하기 전에 README.md 파일에 구현할 기능 목록을 정리해 추가한다.
- git의 commit 단위는 앞 단계에서 README.md 파일에 정리한 기능 목록 단위로 추가한다.
  - 참고문서 : [AngularJS Commit Message Conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)

---
# 미션 진행
### 구현 목표
> 다음과 같은 목표를 달성하기 위해 구현 기능 목록을 산출 한다.
> - 1번의 로또 게임을 생성하고, 지난 주 당첨 번호와 비교하여 결과를 출력한다.
> - N번의 로또 게임을 생성하고, 지난 주 당첨 번호와 비교하여 결과를 출력한다.

### 구현 기능 목록 : TODO List
- [x] 로또 목록 도메인 : 로또 목록 도메인은 N번의 로또 게임을 표현한다.
  - 로또 목록 도메인은 다음과 같은 속성을 가진다.
    - [x] N번의 로또 게임을 표현하는 로또 도메인 목록
  - 로또 목록 도메인은 다음과 같은 기능을 가진다.
    - [x] N번의 로또 게임을 지난 주 당첨 번호와 비교하여 당첨 통계 객체를 반환

- [x] 로또 도메인 : 로또 도메인은 1~45 범위의 6개 숫자를 가지는 한번의 로또 게임을 표현한다.
  - 로또 도메인은 다음과 같은 속성을 가진다.
    - [x] 6개의 로또 번호 목록 : 일급 컬렉션
  - 로또 도메인은 다음과 같은 기능을 가진다. (일급 컬렉션을 이용하여 다음과 같은 기능을 분리)
    - [x] 현재 로또 번호의 갯수 조회
    - [x] 지난 주 당첨 번호와 비교하여 당첨 결과 반환
      - [x] 특정 숫자 포함 여부 반환
      - [x] 지난 주 당첨 번호와 비교하여 포함된 로또 숫자의 개수 반환
      - [x] 지난 주 당첨 번호와 일치하는 로또 번호의 수를 이용하여 해당 하는 당첨 결과 객체 반환  
      - [x] 6개의 로또 번호 정렬
  - 로또 도메인은 다음과 같은 예외 상황을 처리한다. (유효성 검증 및 에외 처리)
    - [x] 6개의 로또 번호를 입력하지 않는 경우
    - [x] 1~45 범위를 벗어나는 숫자가 포함된 경우
    - [x] 중복된 숫자가 포함된 경우
  - 로또 도메인 구현 예시
    ```
        Class LottoNumbers
            List<Integer> lotto
            int size()
            int matchCount()
            boolean contains()
            int compare()
            void print()
            void sort()
    ```
    
- [x] 로또 번호 도메인 : 각 번호는 1~45 숫자 범위를 가져야하는 로또 번호 표현을 위해 원시 타입 포장 객체로 정의 한다.
  - 로또 번호 도메인은 다음과 같은 속성을 가진다.
    - [x] 1개의 로또 번호 : 원시 타입 포장 객체
  - 로또 번호 도메인은 다음과 같은 기능을 가진다.
    - [x] 1개의 로또 번호 조회
  - 로또 번호 도메인은 다음과 같은 예외 사항을 처리한다. (유효성 검증 및 예외 처리)
    - [x] 1~45 범위를 벗어나는 숫자인 경우
  - 로또 번호 도메인 구현 예시 
    ```
        Class LottoNumber
            int number
            public LottoNumber(int number) {
                validateLottoNumberRange(number) // 1~45 범위에 대한 유효성 검사
                this.lottoNumber = number
            }
    ```
  
- [-] 지난 주 당첨 번호 도메인 // 일급 컬렉션으로 구성된 Lotto 객체를 재활용 하면되므로 추가 구현이 필요한지 고민
  - 당첨 번호 도메인은 다음과 같은 속성을 가진다.
    - [-] 정답에 해당하는 6개의 번호 목록
    - [-] 등수 
  - 당첨 번호 도메인은 다음과 같은 기능을 가진다.
    - [-] 1번의 로또 게임을 입력받아 결과를 판별한다. : equals(), hashCode()를 활용해 본다.
    - [-] 다수의 로또를 입력받아 결과를 판별한다.

- [x] 당첨 결과 객체 : 일치하는 당첨 번호 갯수에 따른 등수와 당첨금을 표현한 enum 객체
  - 당첨 결과 객체는 다음과 같은 속성을 가진다.
    - [x] 일치하는 로또 번호 개수에 대한 description
    - [x] 당금금에 대한 description
  - 당첨 결과 객체 예시
    ```
        enum MatchResult
            FIRST_PLACE("6개 일치", "2000000000원"), 
            SECOND_PLACE("5개 일치", "1500000원"), 
            THIRD_PLACE("4개 일치", "50000원"), 
            FORTH_PLACE("3개 일치", "5000원");
            String matchCountDescription // 일치하는 개수
            String rewardDescription // 당첨금
    ```
- [x] 당첨 통계 객체 : 전체 차수 만큼 로또 당첨 여부를 판별한 객체
  - 당첨 통계는 다음과 같은 속성을 가진다.
    - [x] 당첨 결과 객체 목록
    - [x] 6개 로또 번호가 일치한 게임 수
    - [x] 5개 로또 번호가 일치한 게임 수
    - [x] 4개 로또 번호가 일치한 게임 수
    - [x] 3개 로또 번호가 일치한 게임 수
    - [x] 전체 당첨 금액
  - 당첨 통계는 다음과 같은 기능을 가진다.
    - [x] 수익률 계산
  - 당첨 통계 객체 예시
    ```
        Class MatchResults
            List<MatchResult> matchStatistic
            ? statistics() : 동사 혹은 동사구로 표현, statistics 반환을 위해 통계 객체가 추가로 필요한지 고민
            double rateOfProfit() : 동사 혹은 동사구로 표현
            
    ```

- [x] 사용자(고객) 도메인
  - 사용자 도메인은 다음과 같은 속성을 가진다.
    - [x] 로또 발행을 위해 입력받은 금액
    - [x] 금액에 해당하는 횟수 만큼 발행된 로또 목록
  - 사용자 도메인은 다음과 같은 기능을 가진다.
    - [x] 금액에 해당하는 로또 진행 가능한 횟수 조회
    - [x] 로또 진행 가능한 횟수 만큼 로또 발행
  - 사용자 도메인은 다음과 같은 예외를 처리한다.
    - [x] 1000원 이하의 유효하지 못함 금액 입력 시 예외
    - [x] 1000원 단위가 아닌 잔돈이 발생하는 금액 입력 시 예외 
    
- [x] Utils
  - [x] 중복 없는 6개의 난수 목록 생성 부
    - [x] 1~45의 크기를 가진 배열과 Collections.shuffle(), subList()를 이용하여 1회 분량의 로또 번호에 해당하는 중복없는 6자리의 난수 생성
      ```
          각 로또 번호는 1~45의 고정된 범위 내에서 표현됨을 알고 있으므로, 
          1~45의 값을 가지는 int 배열을 Static 영역에 초기화 하여 여러번의 로또 번호 생성 과정에서 재 사용 가능 하도록 구성
      ```

- [x] 입력 부
  - [x] 구입 금액 입력
  - [x] 지난 주 당첨 번호 입력

- [x] 출력 부
  - [x] 구매 금액 입력 안내 메세지 출력
  - [x] 구매 완료 안내 메세지 출력
  - [x] 지난 주 당첨 번호 입력 안내 메세지 출력
  - [x] 당첨 통계 출력
    - [x] 지난 주 당첨 번호와 비교하여, 4~6개 번호가 일치한 로또 수와 해당하는 당첨금액 출력
    - [x] 게임 진행에 소모된 비용 대비 당첨 금액에 대한 수익률 출력
    
- [x] 로또 진행 부
  - [x] *.Application으로 명명된 entrypoint 구현
  - [x] *.Controller로 명명된 View와 Domain 결합 계층 구현
  - [x] *.Service로 명명된 Domain과 Domain 결합 계층 구현
---

# 고민 사항
1. 유효성 검증부 위치에 대한 고민
```
원시 타입 포장 객체는 생성 시점에 비지니스에 관련된 값 등을 보장할 수 있다는 것이 이점이라 생각했음, 원시 타입 포장 객체의 생성자에서 생성 시점에 유효성 검증을 체크하는 것과 *Validator와 같은 유효성 검증부를 따로 분리한 후, 생성자에서 해당 유효성 검증부를 호출하는 것 중 어느 것이 더 올바른 구조인지에 대한 고민 
유효성 검증부를 작성하다 보면 유효성 검증에 대한 기준 값, 유효성 검증에 실패하는 경우 예외 처리 및 예외 처리 시 반환할 에러 메세지 등이 도메인 객체에 녹아들어 이것을 도메인과 결합시키는것이 좋은지, 혹은 Utils과 같이 별도로 분리시키는 것이 좋은지에 대한 고민이 든다.
```

2. 명확하지 않은 문서 작성
```
설계가 명확하지 않으니 두서 없이 장황해지고, 여러 경우의 수를 명시하고 구현하면서 잘못된 설계를 제거해가며 구현하는 것이 좋은 방법인지 모르겠음
도메인에 대한 부족한 분석으로 인해 이해도가 낮아 여러가지 경우의 수를 다 고려하려는 경향이 있음  
```

3. 길어지는 if 문에 대한 고민
```
아래 코드 처럼 분기 케이스가 많아지는 경우 어떻게 개선 할 수 있을지에 대한 고민이 필요
```
```
    private void addPlaceCount(MatchResult matchResult) {
        if (matchResult.isFirstPlace()) {
            this.firstPlaceCount++;
        }
        if (matchResult.isSecondPlace()) {
            this.secondPlaceCount++;
        }
        if (matchResult.isThirdPlace()) {
            this.thirdPlaceCount++;
        }
        if (matchResult.isForthPlace()) {
            this.forthPlaceCount++;
        }
    }
```

4. *Utils Class의 명명에 대한 고민
```
난수 생성 부 자체에 6개의 로또 번호에 대한 로직이 녹아 있으므로,
난수 생성부를 비지니스와 결합도가 높은 LottoNumberUtils로 명명하는 것과
비지니스와 결합도가 떨어지는 RandomNumberUtils로 명명하는 것 중 더 좋은 방법이 무엇인지 에 대한 고민
```
---

# step3 미션 진행에 대한 회고
```
전체 프로그램이 달성해야 하는 목표를 명확하게 인지하고, 이를 달성하기 위해 구현해야 하는 기능 선정 및 기능의 복잡도를 떨어트리기 위해 더 작은 단위로 쪼개면서 진행하게된 결과 지난 미션 진행 보다 체감상 접근과 구현이 쉬웠던 것 같음
여전히 많은 시간을 할애하지만, 속도가 나지 않는 것은 아직 TDD에 익숙하지 않기 때문,
도메인 위주로 설계하고, 설계의 복잡도를 떨어트리면서 구현하는 연습이 많이 필요할 것 같음, 미션 진행 시 반복적으로 고민되는 포인트를 정리하고, 이에 대한 해결 방법을 찾아가는 과정도 필요함
```
